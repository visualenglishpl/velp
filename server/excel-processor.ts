import * as XLSX from 'xlsx';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Process an Excel file and generate TypeScript mapping code
 * @param excelFilePath Path to the Excel file to process
 * @param outputPath Path to save the generated TypeScript file (optional)
 * @returns Record<string, {question: string, answer: string}>
 */
export function processExcelAndGenerateTS(
  excelFilePath: string, 
  outputPath?: string
): Record<string, {question: string, answer: string}> {
  console.log(`Processing Excel file from: ${excelFilePath}`);
  
  // Read the Excel file
  const workbook = XLSX.readFile(excelFilePath);
  
  // Assume first sheet unless specified
  const firstSheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[firstSheetName];
  
  // Convert to JSON
  const jsonData = XLSX.utils.sheet_to_json(worksheet);
  
  console.log(`Found ${jsonData.length} rows in Excel sheet`);
  
  // Create mapping object
  const mapping: Record<string, {question: string, answer: string}> = {};
  
  console.log("Excel data sample:", JSON.stringify(jsonData.slice(0, 3), null, 2));
  
  // Process each row
  for (const row of jsonData) {
    // Type cast row to fix TypeScript errors
    const typedRow = row as Record<string, any>;
    
    // Get the expected column names
    const possibleFilePathColumns = ['File Path', 'FilePath', 'Path', 'Filename', 'File', 'A'];
    const possibleQuestionColumns = ['Question', 'Questions', 'Q', 'B'];
    const possibleAnswerColumns = ['Answer', 'Answers', 'A', 'C'];
    
    // Find the actual column names
    let filePathColumn = possibleFilePathColumns.find(col => typedRow[col] !== undefined);
    let questionColumn = possibleQuestionColumns.find(col => typedRow[col] !== undefined);
    let answerColumn = possibleAnswerColumns.find(col => typedRow[col] !== undefined);
    
    // Log the column structure of first row
    if (jsonData.indexOf(row) === 0) {
      console.log("Column structure found:", { filePathColumn, questionColumn, answerColumn });
      console.log("Available columns:", Object.keys(typedRow).join(", "));
    }
    
    // Skip rows without required data
    if (!filePathColumn || !questionColumn || !answerColumn || 
        !typedRow[filePathColumn] || !typedRow[questionColumn] || !typedRow[answerColumn]) {
      continue;
    }
    
    // Get the filename from the path
    const filePath = String(typedRow[filePathColumn]);
    
    // Handle different path formats - might be full path or just filename
    let fileName = filePath;
    if (filePath.includes('/') || filePath.includes('\\')) {
      fileName = path.basename(filePath);
    }
    
    // Store the mapping with the filename as key
    mapping[fileName] = {
      question: String(typedRow[questionColumn]),
      answer: String(typedRow[answerColumn])
    };
    
    // Also store without file extension to make matching easier
    const fileNameWithoutExt = fileName.replace(/\.(png|jpg|jpeg|gif|mp4)$/i, '');
    if (fileNameWithoutExt !== fileName) {
      mapping[fileNameWithoutExt] = {
        question: String(typedRow[questionColumn]),
        answer: String(typedRow[answerColumn])
      };
    }
  }
  
  console.log(`Generated mapping for ${Object.keys(mapping).length} files`);
  
  // Generate TypeScript file if outputPath is provided
  if (outputPath) {
    const tsCode = generateTypescriptCode(mapping);
    fs.writeFileSync(outputPath, tsCode);
    console.log(`TypeScript file generated at: ${outputPath}`);
  }
  
  return mapping;
}

/**
 * Generate TypeScript code for the mapping
 * @param mapping The mapping object to convert to TypeScript
 * @returns TypeScript code as a string
 */
function generateTypescriptCode(mapping: Record<string, {question: string, answer: string}>): string {
  // Format the mapping as a TypeScript object
  const entries = Object.entries(mapping)
    .map(([key, {question, answer}]) => {
      // Escape any quotes in the strings
      const escapedKey = key.replace(/"/g, '\\"');
      const escapedQuestion = question.replace(/"/g, '\\"');
      const escapedAnswer = answer.replace(/"/g, '\\"');
      
      return `  "${escapedKey}": {\n    question: "${escapedQuestion}",\n    answer: "${escapedAnswer}"\n  }`;
    })
    .join(',\n');
  
  // Generate the full TypeScript file content
  const tsCode = `// This file is auto-generated by excel-processor.ts
// Generated on ${new Date().toISOString()}

export interface QuestionAnswer {
  question: string;
  answer: string;
}

export const questionAnswerMapping: Record<string, QuestionAnswer> = {
${entries}
};

/**
 * Extract a code pattern like "01 A a" from a filename
 */
function extractCodePattern(text: string): string | null {
  // Try to match patterns like "01 I A" or "05 L C"
  const codeMatch = text.match(/(\d{2})\\s+([A-Za-z])\\s+([A-Za-z])/i);
  if (codeMatch) {
    // Return standardized format for matching: "01 a a"
    return \`\${codeMatch[1]} \${codeMatch[2].toLowerCase()} \${codeMatch[3].toLowerCase()}\`;
  }
  return null;
}

/**
 * Find the closest matching Q&A for a given filename
 * @param filename The filename to match
 * @returns The matching Q&A or undefined if no match
 */
export function findMatchingQA(filename: string): QuestionAnswer | undefined {
  console.log("Looking for Q&A mapping for:", filename);
  
  // First, try an exact match
  if (questionAnswerMapping[filename]) {
    console.log("Found exact match for:", filename);
    return questionAnswerMapping[filename];
  }
  
  // If no exact match, try to find a match by cleaning up the filename
  const cleanedFilename = filename
    .replace(/\\.(png|jpg|jpeg|gif|webp|mp4)$/i, '') // Remove file extensions
    .trim();
    
  if (questionAnswerMapping[cleanedFilename]) {
    console.log("Found match for cleaned filename:", cleanedFilename);
    return questionAnswerMapping[cleanedFilename];
  }
  
  // Try to match by code pattern (like "01 A a")
  const codePattern = extractCodePattern(filename);
  if (codePattern) {
    console.log("Extracted code pattern:", codePattern, "from filename:", filename);
    
    // Look for matches based on the code pattern
    for (const [key, qa] of Object.entries(questionAnswerMapping)) {
      if (key.toLowerCase().includes(codePattern.toLowerCase())) {
        console.log("Found code pattern match:", key);
        return qa;
      }
    }
  }
  
  // If still no match, try if any key is a substring of filename
  for (const [key, qa] of Object.entries(questionAnswerMapping)) {
    if (filename.includes(key)) {
      console.log("Found substring match:", key, "in filename:", filename);
      return qa;
    }
  }
  
  // Try the reverse - if filename is a substring of any key
  for (const [key, qa] of Object.entries(questionAnswerMapping)) {
    if (key.includes(cleanedFilename)) {
      console.log("Found filename as substring in key:", key);
      return qa;
    }
  }
  
  // No match found
  console.log("No mapping match found for:", filename);
  return undefined;
}
`;

  return tsCode;
}