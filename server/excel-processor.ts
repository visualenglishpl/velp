import * as XLSX from 'xlsx';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Process an Excel file and generate TypeScript mapping code
 * @param excelFilePath Path to the Excel file to process
 * @param outputPath Path to save the generated TypeScript file (optional)
 * @returns Record<string, {question: string, answer: string}>
 */
export function processExcelAndGenerateTS(
  excelFilePath: string, 
  outputPath?: string
): Record<string, {question: string, answer: string}> {
  console.log(`Processing Excel file from: ${excelFilePath}`);
  
  // Read the Excel file
  const workbook = XLSX.readFile(excelFilePath);
  
  // Assume first sheet unless specified
  const firstSheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[firstSheetName];
  
  // Convert to JSON
  const jsonData = XLSX.utils.sheet_to_json(worksheet);
  
  console.log(`Found ${jsonData.length} rows in Excel sheet`);
  
  // Create mapping object
  const mapping: Record<string, {question: string, answer: string}> = {};
  
  // Process each row
  for (const row of jsonData) {
    // Skip rows without required data
    if (!row['File Path'] || !row['Question'] || !row['Answer']) {
      continue;
    }
    
    // Get the filename from the path
    const filePath = String(row['File Path']);
    const fileName = path.basename(filePath);
    
    // Store the mapping with the filename as key
    mapping[fileName] = {
      question: String(row['Question']),
      answer: String(row['Answer'])
    };
  }
  
  console.log(`Generated mapping for ${Object.keys(mapping).length} files`);
  
  // Generate TypeScript file if outputPath is provided
  if (outputPath) {
    const tsCode = generateTypescriptCode(mapping);
    fs.writeFileSync(outputPath, tsCode);
    console.log(`TypeScript file generated at: ${outputPath}`);
  }
  
  return mapping;
}

/**
 * Generate TypeScript code for the mapping
 * @param mapping The mapping object to convert to TypeScript
 * @returns TypeScript code as a string
 */
function generateTypescriptCode(mapping: Record<string, {question: string, answer: string}>): string {
  // Format the mapping as a TypeScript object
  const entries = Object.entries(mapping)
    .map(([key, {question, answer}]) => {
      // Escape any quotes in the strings
      const escapedKey = key.replace(/"/g, '\\"');
      const escapedQuestion = question.replace(/"/g, '\\"');
      const escapedAnswer = answer.replace(/"/g, '\\"');
      
      return `  "${escapedKey}": {\n    question: "${escapedQuestion}",\n    answer: "${escapedAnswer}"\n  }`;
    })
    .join(',\n');
  
  // Generate the full TypeScript file content
  const tsCode = `// This file is auto-generated by excel-processor.ts
// Generated on ${new Date().toISOString()}

export interface QuestionAnswer {
  question: string;
  answer: string;
}

export const questionAnswerMapping: Record<string, QuestionAnswer> = {
${entries}
};

/**
 * Find the closest matching Q&A for a given filename
 * @param filename The filename to match
 * @returns The matching Q&A or undefined if no match
 */
export function findMatchingQA(filename: string): QuestionAnswer | undefined {
  // First, try an exact match
  if (questionAnswerMapping[filename]) {
    return questionAnswerMapping[filename];
  }
  
  // If no exact match, try to find a match by cleaning up the filename
  const cleanedFilename = filename
    .replace(/\\.(png|jpg|jpeg|gif|webp|mp4)$/i, '') // Remove file extensions
    .trim();
    
  for (const [key, qa] of Object.entries(questionAnswerMapping)) {
    const cleanedKey = key
      .replace(/\\.(png|jpg|jpeg|gif|webp|mp4)$/i, '') // Remove file extensions
      .trim();
      
    if (cleanedFilename === cleanedKey) {
      return qa;
    }
  }
  
  // If still no match, try if the filename contains the key
  for (const [key, qa] of Object.entries(questionAnswerMapping)) {
    if (filename.includes(key)) {
      return qa;
    }
  }
  
  // No match found
  return undefined;
}
`;

  return tsCode;
}